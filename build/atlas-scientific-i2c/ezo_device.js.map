{
  "version": 3,
  "sources": ["../../src/atlas-scientific-i2c/ezo_device.ts"],
  "sourcesContent": ["import * as i2c from 'i2c-bus';\nimport { AtlasScientificEzoI2cAdapter } from '../main';\nconst waitTime=300;\n\n/**\n * A generic Atlas Scientific EZO chip with a common subset of functions.\n */\nexport class EZODevice {\n   \n    i2c_bus: i2c.PromisifiedBus;\n    address: number;\n    waitTime: number;\n    readBufferSize: number;\n    info: string;\n\t\n\tconstructor(i2c_bus: i2c.PromisifiedBus, address: number, info: string, protected readonly adapter: AtlasScientificEzoI2cAdapter) {\n\t\tthis.i2c_bus = i2c_bus;\n\t\tthis.address = address;\n\t\tthis.info = info;\n\t\tthis.readBufferSize = 16;\n\t\tthis.waitTime = 300;\n\n\t}\n\t\n\tDelay():Promise<void>{\n\t\treturn new Promise((resolve,reject)=>{\n\t\t\tthis.adapter.setTimeout(resolve,this.waitTime);\n\t\t});\n\t}\n\n\t/**\n\t * Sends a command to the device, waits 300ms, and then reads back the response.\n\t */\n\tasync SendCommand(command: string):Promise<Buffer>{\n\t\tconst wbuf = Buffer.from(command);\n\t\tconst rbuf = Buffer.alloc(this.readBufferSize);\n\t\treturn new Promise((resolve,reject)=>{\n\t\t\tthis.i2c_bus.i2cWrite(this.address,wbuf.length,wbuf).then(async _=>{\n\t\t\t\tawait this.Delay();\n\t\t\t\tlet r;\n\t\t\t\ttry{\n\t\t\t\t\tr = await this.i2c_bus.i2cRead(this.address,rbuf.length,rbuf);\n\t\t\t\t\t//more than 16 bytes, so we need to keep reading\n\t\t\t\t\tif(r.buffer.indexOf(0)<0){\n\t\t\t\t\t\tlet nr=Buffer.concat([r.buffer]);\n\t\t\t\t\t\twhile(r.buffer.indexOf(0)<0){\n\t\t\t\t\t\t\tr= await this.i2c_bus.i2cRead(this.address,rbuf.length,rbuf);\n\t\t\t\t\t\t\tnr=Buffer.concat([nr,r.buffer]);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tresolve(nr);\n\t\t\t\t\t}else{\n\t\t\t\t\t\tresolve(rbuf);\n\t\t\t\t\t}\n\t\t\t\t}catch(e){reject(e);}\n\t\t\t}).catch(reject);\n\t\t});\n\t}\n\n\t/*\n\tNOTE: all responses start with 0x1, and usually repeat the command that was sent.\n\t*/\n\n\tasync Factory():Promise<void>{\n\t\t//the device reboots, so there will be nothing to read.\n\t\t//Just eat any errors that might crop up.\n\t\tawait this.SendCommand(\"Factory\").catch(error=>{});\n\t}\n\n\t/**\n\t * Fetches the Info string from the device\n\t * Promise<String>\n\t */\n\tasync GetInfo():Promise<string>{\n\t\tthis.waitTime = 300;\n\t\tconst res = (await this.SendCommand(\"I\")).toString().replace(/\\0/g, '');\n\t\treturn res;\n\t}\n\n\tasync SetProtocolLock(lock:string):Promise<void>{\n\t\tthis.waitTime = 300;\n\t\tawait this.SendCommand('Plock,'+(lock?1:0));\n\t}\n\n\t/**\n\t * Returns whether the Protocol currently is locked.\n\t */\n\tasync GetProtocolLocked(): Promise<boolean>{\n\t\tthis.waitTime = 300;\n\t\tconst cmd='Plock,?';\n\t\t//response: _?Plock,n\n\t\treturn (await this.SendCommand(cmd))[cmd.length+1].toString().replace(/\\0/g, '') == '1';\n\t}\n\n\t/**\n\t * Finds the device with a white blinking LED. This will disable continuous mode.\n\t */\n\tasync Find():Promise<void>{\n\t\tthis.waitTime = 300;\n\t\tawait this.SendCommand('Find');\n\t}\n\n\t/**\n\t * Return true if the LED is currently on.\n\t */\n\tasync GetLED(): Promise<boolean>{\n\t\tconst cmd='L,?';\n\t\tthis.waitTime = 300;\n\t\t//respose: _?L,n\n\t\tconst resp = (await this.SendCommand(cmd)).toString().replace(/\\0/g, '');\n\t\treturn resp[cmd.length+1] == '1';\n\t}\n\n\t/**\n\t * Turns the LED On or Off\n\t */\n\tasync SetLED(isOn: boolean):Promise<void>{\n\t\tthis.waitTime = 300;\n\t\tawait this.SendCommand('L,'+(isOn?1:0));\n\t}\n\n\t/**\n\t * Stores a name string on the device.\n\t * Whitespace will be removed. If longer than 16 characters, only the first 16 will be sent. \n\t */\n\tasync SetName(name: string):Promise<void>{\n\t\tthis.waitTime = 300;\n        let n=name.replace(' ','');\n        if(n.length>16)\n            n=n.substr(0,16); \n        await this.SendCommand('Name,'+n)\n    }\n\n\t/**\n\t * Gets the stored name of this device\n\t */\n    async GetName():Promise<string>{\n        const cmd=\"Name,?\";\n\t\tthis.waitTime = 300;\n        const resp = await this.SendCommand(cmd);\n        return (await this.SendCommand(cmd)).toString('ascii',cmd.length+1).replace(/\\0/g, '');\n\t\t//resp.toString('ascii', cmd.length+1).replace(/\\0/g, '');\n    }\n\n\t/**\n     * Enters sleep/low-power mode. Send any character or command to awaken.\n     */\n\tasync Sleep():Promise<void>{\n\t\tthis.waitTime = 300;\n\t\tconst wbuf=Buffer.from('Sleep');\n\t\tawait this.i2c_bus.i2cWrite(this.address,wbuf.length,wbuf);\n\t}\n\n\t/**\n\t * Changes the I2C Address. This causes the device to reboot.\n\t */\n\tasync ChangeI2CAddress(newAddress: number):Promise<void>{\n\t\tthis.waitTime = 300;\n\t\tconst wbuf=Buffer.from(`I2C,${newAddress}`);\n\t\tthis.i2c_bus.i2cWrite(this.address,wbuf.length,wbuf);\n\t\tthis.address=newAddress\n\t}\n\n\t/**\n\t * Fetches the Status string from the device (voltage at Vcc pin and reason for last restart)\n\t * Promise<String> in format \"?Status,X,5.038\" \n\t * X = Restart code -> P = powered off, S = software reset,B = brown out, W = watchdog, U = unknown\n\t */\n\tasync GetDeviceStatus():Promise<string>{\n\t\tthis.waitTime=300;\n\t\tconst res = (await this.SendCommand(\"Status\")).toString('ascii',1).replace(/\\0/g, '');\n\t\treturn res;\n\t}\t\n\t\n}\n\nexport { EZODevice as default };\n"],
  "mappings": "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",
  "names": []
}

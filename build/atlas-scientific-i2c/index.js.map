{
  "version": 3,
  "sources": ["../../src/atlas-scientific-i2c/index.ts"],
  "sourcesContent": ["\nimport { EZODevice } from \"./ezo_device\";\nimport { Pump } from \"./pump\";\nimport { pH } from \"./ph_meter\";\nimport { ORP } from \"./orp_meter\";\nimport { EC } from \"./ec_meter\";\nimport { DO } from \"./do_meter\";\nimport { RTD } from \"./rtd-meter\";\nimport * as i2c from 'i2c-bus';\nimport { AtlasScientificEzoI2cAdapter } from \"../main\";\nimport { Delay } from \"../lib/async\";\n\n\n\n\n/**\n * Returns a promise that resolves into an array of available, EZO class devices.\n * This scans the i2c_bus for in use addresses. It sends each address the \"I\" info command, and if the response matches the EZO pattern, it will instantiate the corresponding wrapper class.\n * If the device is an unknown type, it will instantiate as a generic EZODevice. \n */\n export async function FindAllDevices(i2c_bus: i2c.PromisifiedBus, adapter: AtlasScientificEzoI2cAdapter):Promise<any[]>{\n\tconst info = Buffer.from(\"I\");\n\tconst results = await i2c_bus.scan();\n\tconst writesP=Promise.allSettled(results.map(addr=>{\n\t\t\t\t\treturn i2c_bus.i2cWrite(addr,info.length,info);\n\t\t\t}));\n\tawait writesP;\n\tawait new Delay(300, adapter)\n\tconst readsP=await Promise.allSettled(results.map(addr=>{\n\t\t\tconst rbuf= Buffer.alloc(16);\n\t\t\treturn i2c_bus.i2cRead(addr,rbuf.length,rbuf);\n\t}));\n\n\tconst devices=[];\n\treadsP.forEach((promResult,index)=>{\n\t\t\tif(promResult.status==\"fulfilled\"){\n\t\t\t\t//console.log(promResult.value.buffer.toString());\n\t\t\t\tconst info=promResult.value.buffer.toString();\n\t\t\t\tif(info.indexOf(\"?I,\")>-1){\n\t\t\t\t\tconst devType=info.split(',')[1];\n\t\t\t\t\tif(devType=='PMP'){\n\t\t\t\t\t\tdevices.push(new Pump(i2c_bus,results[index],info, adapter));\n\t\t\t\t\t}else if(devType=='pH'){\n\t\t\t\t\t\tdevices.push(new pH(i2c_bus,results[index],info, adapter));\n\t\t\t\t\t}else if(devType=='DO'){\n\t\t\t\t\t\tdevices.push(new DO(i2c_bus,results[index],info, adapter));\n\t\t\t\t\t}else if(devType=='EC'){\n\t\t\t\t\t\tdevices.push(new EC(i2c_bus,results[index],info, adapter));\n\t\t\t\t\t}else if(devType=='ORP'){\n\t\t\t\t\t\tdevices.push(new ORP(i2c_bus,results[index],info, adapter));\n\t\t\t\t\t}else if(devType=='RTD'){\n\t\t\t\t\t\tdevices.push(new RTD(i2c_bus,results[index],info, adapter));\n\t\t\t\t\t}else{\n\t\t\t\t\t\tdevices.push(new EZODevice(i2c_bus,results[index],info, adapter));\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t}\n\t});\n\treturn devices;\n}\n\nexport { EZODevice, Pump, pH, DO, ORP, EC, RTD };\n\n\n"],
  "mappings": ";;;;;;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA,wBAA0B;AAC1B,kBAAqB;AACrB,sBAAmB;AACnB,uBAAoB;AACpB,sBAAmB;AACnB,sBAAmB;AACnB,uBAAoB;AAGpB,mBAAsB;AAUrB,eAAsB,eAAe,SAA6B,SAAqD;AACvH,QAAM,OAAO,OAAO,KAAK,GAAG;AAC5B,QAAM,UAAU,MAAM,QAAQ,KAAK;AACnC,QAAM,UAAQ,QAAQ,WAAW,QAAQ,IAAI,UAAM;AAC/C,WAAO,QAAQ,SAAS,MAAK,KAAK,QAAO,IAAI;AAAA,EAC/C,CAAC,CAAC;AACJ,QAAM;AACN,QAAM,IAAI,mBAAM,KAAK,OAAO;AAC5B,QAAM,SAAO,MAAM,QAAQ,WAAW,QAAQ,IAAI,UAAM;AACtD,UAAM,OAAM,OAAO,MAAM,EAAE;AAC3B,WAAO,QAAQ,QAAQ,MAAK,KAAK,QAAO,IAAI;AAAA,EAC9C,CAAC,CAAC;AAEF,QAAM,UAAQ,CAAC;AACf,SAAO,QAAQ,CAAC,YAAW,UAAQ;AACjC,QAAG,WAAW,UAAQ,aAAY;AAEjC,YAAMA,QAAK,WAAW,MAAM,OAAO,SAAS;AAC5C,UAAGA,MAAK,QAAQ,KAAK,IAAE,IAAG;AACzB,cAAM,UAAQA,MAAK,MAAM,GAAG,EAAE;AAC9B,YAAG,WAAS,OAAM;AACjB,kBAAQ,KAAK,IAAI,iBAAK,SAAQ,QAAQ,QAAOA,OAAM,OAAO,CAAC;AAAA,QAC5D,WAAS,WAAS,MAAK;AACtB,kBAAQ,KAAK,IAAI,mBAAG,SAAQ,QAAQ,QAAOA,OAAM,OAAO,CAAC;AAAA,QAC1D,WAAS,WAAS,MAAK;AACtB,kBAAQ,KAAK,IAAI,mBAAG,SAAQ,QAAQ,QAAOA,OAAM,OAAO,CAAC;AAAA,QAC1D,WAAS,WAAS,MAAK;AACtB,kBAAQ,KAAK,IAAI,mBAAG,SAAQ,QAAQ,QAAOA,OAAM,OAAO,CAAC;AAAA,QAC1D,WAAS,WAAS,OAAM;AACvB,kBAAQ,KAAK,IAAI,qBAAI,SAAQ,QAAQ,QAAOA,OAAM,OAAO,CAAC;AAAA,QAC3D,WAAS,WAAS,OAAM;AACvB,kBAAQ,KAAK,IAAI,qBAAI,SAAQ,QAAQ,QAAOA,OAAM,OAAO,CAAC;AAAA,QAC3D,OAAK;AACJ,kBAAQ,KAAK,IAAI,4BAAU,SAAQ,QAAQ,QAAOA,OAAM,OAAO,CAAC;AAAA,QACjE;AAAA,MACD;AAAA,IAED;AAAA,EACF,CAAC;AACD,SAAO;AACR;",
  "names": ["info"]
}
